== IN PROGRESS:
1.	Binary Tree
2.	Parsing

	========== IMPORTANT ===========
!!!! Fix leaks when unclosed quotes !!!!!
	========== IMPORTANT ===========

######################################################################
== NOTES:
#1.	File structure: bonus is just additional sources.

2.	Naming functions:
		functions that return allocated spaces that should be freed in the calling
			function (create... OR make...) example: char **create_split_cmds();
		functions that return values that can't be freed (get...) example:
			size_t len_till_splitter();

3.	The WORD tokens shall have the word expansion rules applied to them immediately
		before the associated command is executed, not at the time the command is parsed.

4.	If the token is an operator, the token identifier for that operator shall result.
	If the string consists solely of digits and the delimiter character is one of '<' or '>',
		the token identifier IO_NUMBER shall be returned.
	Otherwise, the token identifier TOKEN results.

5.	TODO:	-Return different numbers from failed deep functions, and handle them differently in
				calling function.

6.	If any part of word is quoted, the delimiter shall be formed by performing quote removal on word,
		and the here-document lines shall not be expanded. Otherwise, the delimiter shall be the word itself.
	If no part of word is quoted, all lines of the here-document shall be expanded for parameter expansion,
		command substitution, and arithmetic expansion. In this case, the <backslash> in the input behaves as
		the <backslash> inside double-quotes (see Double-Quotes). However, the double-quote character ( ' )' shall not
		be treated specially within a here-document, except when the double-quote appears within "$()", "``", or "${}".

7.	Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur
		within a single word expand to a single field. It is only field splitting or pathname expansion that can create
		multiple fields from a single word. The single exception to this rule is the expansion of the special parameter
		'@' within double-quotes, as described in Special Parameters.

8.	The return status (see Exit Status) of a simple command is its exit status as provided by the POSIX 1003.1 waitpid
		function, or 128+n if the command was terminated by signal n.

#9.	Check the output error message of this bash input: (echo hello) hehe"hoho"'haha'
		Can we match the same output with the full token string?

10.	Are you handling empty strings correctly? Example: echo "" || cat ''

11.	Token validations should not be separate. Validate all types of tokens in one iteration, so that the first error
		token we meet is returned. Ask Michal and others if it's no big difference.

12.	Don't forget 0>output, 1023>output, 1024<input, 2147483648<input...

13.	Should we put a hard limit to how many nested or not nested (), how many || and/or | we can have in input? to avoid
		edge case trouble.

14. Should I always store the str of the token? or maybe only when I need it for validate_close_parent(), when
		I need to print it?

15.	Check created files when you input these:
		echo hello 10000>output1 | echo str2 20000>output2 && echo str3 30000>output3
		echo hello 10000>output1 | echo str2 20>output2 && echo str3 30000>output3
		echo hello 20>output1 | echo str2 20000>output2 && echo str3 30000>output3

16.	Maybe make a function that does ft_strjoin() behaviour, but it works with t_fragments (star and end indices of substr)

17.	When expanding "$23hello", should we expand consider "23hello" as the environment variable name? or should we
		consider it an error, since we can't have environment variable names that start with digits? or should we
		handle positional paremeters expansions ("$[number]")? NO :D
	We have to make our "export" give error on names that start with digits.

18.	Check what happens when you input space and/or tabs only to the prompt.